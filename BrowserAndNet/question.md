# ***浏览器与网络知识问答***
**说明**
* 以下涉及的浏览器无特殊说明便指chrome。
</br>
***

## **1.浏览器有哪些组成?分别负责什么事?浏览器多个tab是多个什么？**
1. 用户界面：地址栏，前进后退，书签菜单
2. 呈现引擎：负责显示请求的内容
3. 浏览器引擎：在用户界面和呈现引擎之前的传送命令
4. 网络，唯一的多线程。
5. 用户界面后端：用于基本的弹窗绘制，绘制呈现树。
6. js解释器：解析执行JS
7. 数据存储：Cookie, storage等

Chrome中多个tab页是多个独立的进程，多个呈现引擎实例。FF和Safari中呈现引擎就是浏览器主线程。
***

## **2.JS执行是哪个进程？CSS呢**
JS是由Javascript解释器解释并执行的，css是由呈现引擎解析并构建style rules;
***

## **3.url输入到页面展示的过程？ 缓存校验发生在其中的哪步？哪步导致浏览器的哪个进程间切换？**

>请求：呈现引擎从网络层获取请求文档的内容

>构建（同步）：呈现引擎会将HTML文本进行词法分析并同步构建DOM树。遇到CSS链接会并发解析CSS文档转化成样式规则对象。遇到script会请求文件如果碰到async由其他线程解析执行，defer延后，其他立即执行。DOM构建完后将文档标注为可交互状态，解析deferred的js，然后将文档设置成完成，触发onload。

>附加：DOM构建过程中会匹配CSS规则附加成呈现树(排列好的不包含位置和大小的矩形)，如果附加过程中顶级样式表未加载完，则标注文档，使用占位符先计算，等待加载玩后重新计算。

>布局：基于流式布局计算几何信息和位置，递归呈现树调用呈现器的layout方法。盒子。
脏值检测（增量异步布局）-当呈现器出现变化时标记 dirty或者 children are dirty。调度程序统一dirty元素重新布局。获取offsetxxx,clientxxx的脚本会触发增量布局。
全局布局（同步布局）-当浏览器窗口变化或者所有呈现器的全局样式变更
布局过程：(递归)
>>1. 父确定宽度
>>2. 放置子，调用子的布局，计算出子高度
>>3. 根据子高度和边距，margin求出自身高度。
>>4. dirty = false.
>>+ 换行：子呈现器如果需要换行会立即停止布局并告知父呈现器，父呈现器会创建新的子呈现器，并对其调用布局。

>绘制：调用呈现器的paint方法,调用用户界面后端将每个节点绘制出来.
绘制分全局和增量，增量绘制中有变更的呈现器会将屏幕上对应的矩形区域设为dirty,并发生paint事件。等待OS重新绘制，chrome会监听呈现树变更事件，找到呈现器并触发呈现器重新绘制自己和子代。
*绘制优化：chrome会将原来的矩形另存为位图，只绘制新旧位图的差异部分。FF将呈现器句柄赋值给了矩形
***
## **4.浏览器的缓存分级哪些？什么文件存什么缓存，有什么区别。**
  
***
## **5.DOM，CSSOM，Javscript的解析过程？**
>与上下文无关的语法解析过程（语法多为BNF）：词法分析-语法分析-翻译
解析器调用词法分析器进行词法分析，过滤多余空格和换行，将字符串匹配成token.解析器再请求词法分析器获取一个token进行语法分析将token与内定的语法规则进行匹配，如果匹配就将该节点添加到解析树中，否则继续请求词法分析器获取下一个token。直到匹配规则，如果都匹配则报语法错误。将解析树进行翻译(js)

>与上下文有关的语法解析过程(DOM语法为SGML族： 词法分析-树构建)
DOM解析过程：自定义解析器解析HTML使用标记化算法将其标记化，标记化算法使用状态机表示，当前标记和树结构影响下一个状态。状态机中维护的状态有：标记打开状态、标记名称状态、数据状态
DOM树构建过程也是状态机，状态有：initial mode - before html(创建HTMLElement) - before xxx(创建一个 xxxElement) - in xxx(创建Text或者新的Elment节点)- after xxx - after after body(关闭前最后一个状态) - EOF

***
## **6.预解析？**
#渲染引擎执行JS过程中，其他线程会预解析剩余DOM中的网络资源进行请求。

***
## **7.DOM,CSS,JS执行互相阻塞？**
#非defer或asyns的js执行会阻塞DOM构建,在FF下css请求会完全阻塞JS执行，在Chrome下只有该脚本试图访问样式属性时会被阻塞。

***
## **8.DOM与呈现树的关系？**
1. 非可视化的DOM节点不会出现在呈现树上：head,display = none的
2. 部分DOM节点对应多个呈现器：Select、多行文本、inline元素内出现混合的Block和inline（css规定inline元素只能包含block或inline中的一种）
3. DOM元素的attach方法会创建renderObject，将节点插入DOM会调用attach。
4. html和body标记会创建一个浏览器视口大小的Block。

***
## **9.呈现器的样式计算？**
>样式表散列映射：
将每条规则识别id选择器，类选择器，元素选择器等，将其插入到id表，类表，元素表等中，DOM节点如果右id,class等只需要从相应表中获取对应key的规则，再判断规则是否符合。

>FF:规则树和规则上下文树，Chrome：规则共享，DOM节点指向样式对象：
规则树指1个DOM节点命中多个规则，则按优先级上述（如 先拿命中的id规则，然后作为命中的class规则子节点，class作为元素规则的子节点，感觉应该是个双向树），规则上下文树保存最下层的id规则的指针。DOM节点的样式属性寻找过程：1.先找规则树节点上保存的规则指针，如果命中属性则应用2.没找到上述其父节点，找到就应用3.根节点也没有则继承属性继承规则树父节点，非继承属性则使用默认值。
webkit会遍历4次匹配的规则，应用顺序：1，高优先级非重要2.高优先级重要3.低优先级非重要4.低优先级重要。

***
## **10.布局方式？**

1. 盒类型-block、inline、inline-block等display属性
    - block拥有自己的矩形区域，垂直
    - inline没有自己的矩形区域，位于block内，水平。 inline放置在行框内，行框的高度不低于其中的所有inline元素。宽度不够会换行，增加一个行框。
2. 盒尺寸-盒模型的计算后的尺寸
3. 定位方案
    + 普通流定位：static,relative，不脱离文档流
    + 浮动：作为inline-block元素浮动到左边或者右边，与附近行内元素（没有被Block元素隔开的行内元素）排在一个行框中，并占据行框。
        >- 如果前后都是Block或者没有前则后一个Block会发生塌陷,且会占据Block内的文字所在行框（Block文字宽度不够会换行）。
        >- 除上面外都不会塌陷。
        >- 如果浮动元素高度超过行内高度，则会占据下一个行框的左边或右边。
        总结：行内没有兄弟就会塌，超过高度就会掉。
    + 绝对：脱离文档流。absolute,fixed
4. 外部信息-父容器大小，图片，屏幕大小。

***
## **11.BFC？**
块级格式上下文，具有以下特性：
1. 同BFC内部Block元素与BFC元素之间的margin正常(正常文档流margin为0)，但是Block与Block本身会有margin重叠，解决办法，新建BFC包裹。
2. BFC不与float重叠，可以做2行，3行自适应
3. BFC高度计算会算上浮动元素

***
## **三列中间自适应布局？**
块级格式上下文，具有以下特性：
1. 同BFC内部Block元素与BFC元素之间的margin正常(正常文档流margin为0)，但是Block与Block本身会有margin重叠，解决办法，新建BFC包裹。
2. BFC不与float重叠，可以做2行，3行自适应
3. BFC高度计算会算上浮动元素

***
## **未知宽高左右高度自适应？**
块级格式上下文，具有以下特性：
1. 同BFC内部Block元素与BFC元素之间的margin正常(正常文档流margin为0)，但是Block与Block本身会有margin重叠，解决办法，新建BFC包裹。
2. BFC不与float重叠，可以做2行，3行自适应
3. BFC高度计算会算上浮动元素

***
1.http报文在TCP连接中的表示方式？
2.http协议版本？分别做了什么改进？
3.为什么要四次挥手（2,3次可以合并么）？挥手和握手过程中的丢包处理是怎样的？
4.TCP,UDP区别和优缺点？TCP可靠性如何保证？


1.多Tab页如何通信？
2.跨域解决方案？
3.jsonp跨域优缺点
